{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>This is a place where I host some documentation related to courses I give.</p>"},{"location":"bba2_math/","title":"Contents","text":"<p>Time series smoothing and forecasting</p> <p>Time series decomposition</p> <p>ABC classification</p>"},{"location":"bba2_math/abc/","title":"ABC classification","text":"<p>ABC classification is a simple method to form 3 (or 4) groups of objects based on the distribution of some value associated with them. </p> <p>It is greatly inspired by the 80/20 Pareto rule, indicating that often 80% of a measure (for instance the revenue) comes from only 20% of objects (for instance customers).</p> <p>The archetypical example is to classify customers based on the amount of revenue they bring to a company.</p>"},{"location":"bba2_math/abc/#definitions-and-notations","title":"Definitions and notations","text":"<ul> <li>We will consider \\(N\\) objects </li> <li>\\(M_i\\): the measure for object \\(i\\) that corresponds to the classification criterion</li> <li>\\(P_i\\): the proportion of \\(M_i\\) with respect to the total measure.</li> </ul> <p>\\(\\displaystyle P_i = \\frac{M_i}{\\sum_{i=1}^{N} M_i }\\) - \\(f\\): the frequency, which is equal to \\(1/N\\)</p>"},{"location":"bba2_math/abc/#methodology","title":"Methodology","text":"<ol> <li>Define properly your business objective (what are the measure you are interested in? It may require to preprocess your data, building pivot tables for instance)</li> <li>Gather the data needed to perform the classification</li> <li>Identify the measure \\(M\\) that will be the classification criterion</li> <li>Sort your objects in descending order according to that measure</li> <li>Compute the frequency (constant \\(f\\)), the cumulated frequency (cumulative sum of \\(f\\)), the proportion \\(P_i\\) and the cumulative proportion (cumulative sum of \\(P_i\\))</li> <li>Plot a Pareto chart (cumulative proportion versus cumulative frequency)</li> <li>Plot also the diagonal line</li> <li>Classify your objects in 3 classes using the empirical rule defined below</li> </ol>"},{"location":"bba2_math/abc/#excel-implementation","title":"Excel implementation","text":"<p>Using Excel, you should use the following columns to perform the classification:</p> <ul> <li>Object: The object your are considering</li> <li>\\(M\\): The measure that drives the classification for each object. Your table should be sorted in descending order based on that column</li> <li>\\(f\\): The frequency (\\(f = 1/N\\))</li> <li>\\(C_f\\): The cumulative frequency</li> <li>\\(P\\): The proportion of \\(M\\)</li> <li>\\(C_P\\): The cumulative proportion (cumulative sum of \\(P\\))</li> <li>\\(S_i\\): The trapeze area for the current point: \\(S_i = \\frac{1}{2} f (C_{P_i}+C_{P_{i-1}})\\). When \\(i=1\\), use \\(S_1 = \\frac{1}{2} f C_{P_i}\\)</li> </ul> <p>Then, outside your object table, you need to compute the following quantities:</p> <ul> <li>\\(S1\\): the area under the curve, which is the sum of \\(S\\): \\(\\displaystyle S1 = \\sum_{i=1}^{N} S_i\\)</li> <li>\\(S\\): the area between the diagonal and the curve: \\(S= S1-0.5\\)</li> <li>\\(B\\): the area above the curve: \\(B=1-S1\\)</li> <li>\\(G\\): the Gini index: \\(\\displaystyle G = \\frac{S}{S+B}\\)</li> </ul> <p>## Classification</p> <p>Then based on the value of the Gini index \\(G\\), you can use the following empirical rules:</p> G Class A Class B Class C \\(0.90 &lt; G &lt; 1.00\\) 10% 10% 80% \\(0.85 &lt; G &lt; 0.90\\) 10% 20% 70% \\(0.75 &lt; G &lt; 0.85\\) 20% 20% 60% \\(0.60 &lt; G &lt; 0.75\\) 20% 30% 50% <p>**\\(G &lt; 0.6\\) indicates that no classification can take place.</p> <p>This reads that if \\(G=0.95\\), the class A should contain the first 10% of objects, the class B the next 10% and class C all other customers.</p> <p>Similarly, if \\(G=0.70\\), the class A should contain the first 20% of objects, the class B the next 30% and class C all other customers.</p>"},{"location":"bba2_math/time_series/","title":"Time series","text":"<p>This document describes statistical methods that can used for time series smoothing and forecasting, with associated formulas and practical usage with Excel.</p>"},{"location":"bba2_math/time_series/#notations","title":"Notations","text":"<p>Here is a list of the notations used throughout this document</p> <ul> <li>\\(Y_t\\): the data value at time \\(t\\) </li> <li>\\(F_t\\): the forecasted value at time \\(t\\) </li> <li>\\(G_t\\): the smoothed value at time \\(t\\) </li> <li>\\(S_t\\): the seasonal coefficient at time \\(t\\)</li> <li>\\(R_t\\): the residual at time \\(t\\)</li> <li>\\(T_t\\): the trend at time \\(t\\)</li> </ul>"},{"location":"bba2_math/time_series/#moving-average","title":"Moving average","text":"<p>Simple and efficient way to smooth the data, equivalent to the convolution of the signal by a window. Weighted moving average allows to control the weight of observation, shaping different types of window.</p>"},{"location":"bba2_math/time_series/#smoothing","title":"Smoothing","text":"<p>When using the moving average method to smooth the data (i.e. to soften sudden changes), then a central moving average is computed. Example to compute a CMA3:</p> <p>$\\displaystyle G_t = \\frac{Y_{t-1} + Y_{t} + Y_{t+1}}{3} $</p> <p>When the number of coefficient is even, then the formula reads (for CMA4):</p> <p>$\\displaystyle G_t = \\frac{\\frac{1}{2}Y_{t-2} + Y_{t-1} + Y_{t} + Y_{t+1} + \\frac{1}{2}Y_{t+2}}{3} $</p>"},{"location":"bba2_math/time_series/#forecast","title":"Forecast","text":"<p>When using the moving average method to forecast (i.e. predict future values), then a moving average is computed on past values only! Example to compute a MA3:</p> <p>$\\displaystyle F_t = \\frac{Y_{t-3} + Y_{t-2} + Y_{t-1}}{3} $</p> <p>Weights can be applied:</p> <p>$\\displaystyle F_t = \\frac{w_3 Y_{t-3} + w_2 Y_{t-2} + w_1 Y_{t-1}}{w_1 + w_2 + w_3} $</p> <p>More generally for weighted MA \\(N\\) :</p> <p>$\\displaystyle F_t = \\frac{1}{\\sum_{i=1}^{N} w_i} ~~\\sum_{i=1}^{N} w_{i} Y_{t-i}  $</p>"},{"location":"bba2_math/time_series/#simple-exponential-smoothing","title":"Simple exponential smoothing","text":"<p>Recursive way to smooth the data, with exponentially decreasing weights, controlled by one parameter: \\(\\alpha\\)</p> <p>Simple exponential smoothing is good for data with no trend and no seasonality!</p>"},{"location":"bba2_math/time_series/#smoothing_1","title":"Smoothing","text":"<p>When smoothing data, the recursive formula reads:</p> <p>\\(G_t = \\alpha Y_t + (1-\\alpha)G_{t-1}\\)</p> <p>with initialization: \\(G_0 = Y_0\\)</p>"},{"location":"bba2_math/time_series/#forecast_1","title":"Forecast","text":"<p>When forecasting data, the recursive formula reads:</p> <p>\\(F_t = \\alpha Y_{t-1} + (1-\\alpha)F_{t-1}\\)</p> <p>with initialization: \\(G_0 = Y_0\\)</p>"},{"location":"bba2_math/time_series/#double-exponential-smoothing","title":"Double exponential smoothing","text":"<p>The idea is to apply exponential smoothing twice (we use the result of the first smoothing to estimate the trend). In the course we use Brown's linear exponential smoothing. Double exponential smoothing is only used to do forecast.</p> <p>The recursive formula reads:</p> <p>\\(s'_t = \\alpha Y_t + (1-\\alpha)s'_{t-1}\\)</p> <p>\\(s''_t = \\alpha s'_t + (1-\\alpha)s''_{t-1}\\)</p> <p>\\(a_t = 2s'_t - s''_t\\)</p> <p>\\(b_t = \\frac{\\alpha}{\\alpha - 1} (s'_t - s''_t)\\)</p> <p>\\(\\displaystyle F_{t+m} = a_t + m b_t\\)</p> <p>Double exponential smoothing is good for data with trend and no seasonality!</p>"},{"location":"bba2_math/time_series/#alternative","title":"Alternative","text":"<p>Another way to apply exponential smoothing is Holt's linear, which uses 2 parameters (\\(\\alpha\\) and \\(\\beta\\)).</p> <p>\\(s_0 = Y_0\\)</p> <p>\\(b_0 = Y_1 - Y_0\\)</p> <p>\\(s_t =  \\alpha Y_t + (1-\\alpha)(s_{t-1} + b_{t-1})\\)</p> <p>\\(b_t =  \\beta (s_t - s_{t-1}) + (1-\\beta)b_{t-1}\\)</p> <p>\\(\\displaystyle F_{t+m} = s_t + m b_t\\) </p>"},{"location":"bba2_math/time_series_decomposition/","title":"Time series decomposition","text":"<p>This document describes statistical methods that can used for time series decomposition, with associated formulas and practical usage with Excel.</p> <p>To make better forecast, it is usually required to separate the time series into different parts:</p> <ul> <li>The trend \\(T_t\\): model the low frequency variation, can be fit to a linear evolution</li> <li>The seasonality component \\(S_t\\): model periodic variations. First step is to identify the period, and second step is to estimate \\(S_t\\)</li> <li>The residuals \\(R_t\\): the random variation, that should have zero mean</li> </ul> <p>There are two classical models (we will only focus on them for this course):</p> <ul> <li>the additive model, where \\(Y_t = T_t + S_t + R_t\\)</li> <li>the multiplicative model, where \\(Y_t = T_t \\times S_t \\times R_t\\)</li> </ul> <p>But more generally, each component can be either additive or multiplicative.</p>"},{"location":"bba2_math/time_series_decomposition/#notations","title":"Notations","text":"<p>Here is a list of the notations used throughout this document</p> <ul> <li>\\(Y_t\\): the data value at time \\(t\\) </li> <li>\\(F_t\\): the forecasted value at time \\(t\\) </li> <li>\\(G_t\\): the smoothed value at time \\(t\\) </li> <li>\\(S_t\\): the seasonal coefficient at time \\(t\\)</li> <li>\\(R_t\\): the residual at time \\(t\\)</li> <li>\\(T_t\\): the trend at time \\(t\\)</li> </ul>"},{"location":"bba2_math/time_series_decomposition/#step-by-step-methodology","title":"Step by step methodology","text":"<ol> <li>VIZ: Plot the time series, it is very important to take a look at the evolution of what you are studying. Clearly identify sampling frequency (daily, weekly, monthly, quarterly, yearly?).</li> <li>TREND: Identify if there is a trend, and whether trend is additive or multiplicative (is trend linear?)</li> <li>SEASONALITY: Identify if there is seasonality, and whether seasonality is additive or multiplicative (is the amplitude of period fluctuation increasing with time?) and it's period.</li> <li>MODEL: Build a model (additive or multiplicative for trend/seasonality) for your data and write the associated equation</li> </ol> <p>From here, methodologies are different for additive or multiplicative models</p>"},{"location":"bba2_math/time_series_decomposition/#additive-model","title":"Additive model","text":"<ol> <li>ESTIMATE TREND: Estimate the trend \\(\\hat{T_t}\\) using central moving average or exponential smoothing. </li> <li>DETREND DATA= Compute the detrended time series \\(D_t = Y_t - \\hat{T_t}\\) </li> <li>ESTIMATE SEASONAL COMPONENT: Use \\(D_t\\) to estimate seasonal component. You should average the values of the coefficient for each similar period (for instance, average all January component for yearly seasonality and monthly data). This gives \\(\\hat{S_t}\\) which is periodic.</li> <li>ESTIMATE REMINDER: Estimate the residuals \\(R_t = Y_r - \\hat{T_t} - \\hat{S_t})\\)</li> <li>EVALUATE YOUR MODEL: Before starting to forecast, plot \\(Y\\), \\(S\\), \\(T\\) and \\(R\\) and make sure your decomposition is sound.</li> <li> <p>FORECAST MODEL: To perform a forecast, we usually use \\(Y_t = A_t + S_t\\), regrouping trend and residuals into \\(A_t = T_t + R_t\\). </p> <ul> <li>The seasonal component will remain periodic with the same values. </li> <li>A linear regression is performed on \\(A_t\\) so \\(a\\) and \\(b\\) are estimated and we have \\(\\hat{A_t} = at + b + R_t\\).</li> <li>Since \\(\\hat{R_t}\\) has no trend and no seasonality, a simple exponential smoothing can be used to forecast its values \\(\\hat{R_r}\\). Values in the future will simply be equal to the last forecast.</li> <li>FORECAST: Now to compute the forecast, just apply \\(F_t = \\hat{A_t} + \\hat{S_t}\\), which is equivalent to: \\(\\displaystyle F_t = at + b + \\hat{R_r} + \\hat{S_t}\\)</li> </ul> </li> </ol> <p>When using Excel to build such a model, you should have the folowing columns:</p> <ul> <li>\\(t\\): (1 to \\(N\\))</li> <li>\\(Y\\): Data points</li> <li>\\(\\hat{T_t}\\): Central moving average with \\(k\\) points (k being the seasonal period)</li> <li>\\(D\\): Detrended time series \\(Y - \\hat{T_t}\\)</li> <li>\\(S\\): Seasonal component</li> <li>\\(A\\): Seasonally adjusted component \\(Y - S\\)</li> <li>\\(T\\): \\(at + b\\) using \\(a\\) and \\(b\\) from the linear regression of \\(A\\) vs \\(t\\)</li> <li>\\(R\\): Residuals \\(Y-S-T\\)</li> <li>\\(\\hat{R}\\): Forecast of \\(R\\) using exponential smoothing with \\(\\alpha\\) being either fixed or solved to minimize the standard error.</li> <li>\\(F\\): Forecast of \\(Y\\)</li> <li>\\(SE\\): Standard error</li> </ul>"},{"location":"bba2_math/time_series_decomposition/#multiplicative-model","title":"Multiplicative model","text":"<ol> <li>ESTIMATE TREND: Estimate the trend \\(\\hat{T_t}\\) using central moving average or exponential smoothing. </li> <li>DETREND DATA= Compute the detrended time series \\(D_t = Y_t / \\hat{T_t}\\) </li> <li>ESTIMATE SEASONAL COMPONENT: Use \\(D_t\\) to estimate seasonal component. You should average the values of the coefficient for each similar period (for instance, average all january component for yearly seasonality and monthly data). This gives \\(\\hat{S_t}\\) which is periodic.</li> <li>ESTIMATE REMINDER: Estimate the residuals \\(\\displaystyle R_t = \\frac{Y_r}{\\hat{T_t}\\hat{S_t}}\\)</li> <li>EVALUATE YOUR MODEL: Before starting to forecast, plot \\(Y\\), \\(S\\), \\(T\\) and \\(R\\) and make sure your decomposition is sound.</li> <li>FORECAST MODEL: To perform a forecast, we usually use \\(Y_t = A_t \\times S_t\\), regrouping trend and residuals into \\(A_t = T_t \\times R_t\\). The seasonal component will remain periodic with the same value, and any model for \\(A_t\\) can be used.</li> <li>FORECAST: Now to forecast apply, just apply \\(F_t = \\hat{A_t} + \\hat{S_t}\\)</li> </ol> <p>When using Excel to build such a model, you should have the folowing columns:</p> <ul> <li>\\(t\\) (1 to \\(N\\))</li> <li>\\(Y\\): Data points</li> <li>\\(\\hat{T_t}\\): Central moving average with \\(k\\) points (k being the seasonal period)</li> <li>\\(D\\): Detrended time series \\(Y/\\hat{T_t}\\)</li> <li>\\(S\\): Seasonal component</li> <li>\\(A\\): Seasonally adjusted component \\(Y / S\\)</li> <li>\\(T\\): \\(at + b\\) using \\(a\\) and \\(b\\) from the linear regression of \\(A\\) vs \\(t\\)</li> <li>\\(R\\): Residuals \\(Y/(S\\times T)\\)</li> <li>\\(\\hat{R}\\): Forecast of \\(R\\) using exponential smoothing with \\(\\alpha\\) being either fixed or solved to minimize the standard error.</li> <li>\\(F\\): Forecast of \\(Y\\)</li> <li>\\(SE\\): Standard error</li> </ul>"},{"location":"bba2_math/time_series_decomposition/#example","title":"Example","text":"<p>Here is an example of a time series decomposition.</p> <p></p>"},{"location":"knime/","title":"Using knime with Python","text":"<p>To use Knime and Keras/Tensorflow deep learning libraries, you need to setup Python environments with particular versions of each library.</p> <p>You should do so using <code>anaconda</code> or <code>miniconda</code>.</p>"},{"location":"knime/#knime-default-environnment","title":"Knime default environnment","text":"<p>This is the requirements.txt for the basic knime env (recent one, here with Python 3.11.5):</p> <pre><code>Package                 Version\n----------------------- ------------\nabsl-py                 1.4.0\naiohttp                 3.8.5\naiosignal               1.2.0\nastunparse              1.6.3\nasync-timeout           4.0.2\nattrs                   23.1.0\nblinker                 1.6.2\nBottleneck              1.3.5\nBrotli                  1.0.9\ncachetools              4.2.2\ncertifi                 2023.11.17\ncffi                    1.16.0\ncharset-normalizer      2.0.4\nclick                   8.1.7\ncryptography            41.0.3\nflatbuffers             1.12\nfrozenlist              1.4.0\ngast                    0.4.0\ngoogle-auth             2.22.0\ngoogle-auth-oauthlib    0.5.2\ngoogle-pasta            0.2.0\ngrpcio                  1.48.2\nh5py                    3.9.0\nidna                    3.4\ninstall                 1.3.5\njoblib                  1.2.0\nkeras                   2.12.0\nKeras-Preprocessing     1.1.2\nMarkdown                3.4.1\nMarkupSafe              2.1.1\nmultidict               6.0.2\nnumexpr                 2.8.7\nnumpy                   1.23.5\noauthlib                3.2.2\nopt-einsum              3.3.0\npackaging               23.1\npandas                  2.1.1\npip                     23.3\nprotobuf                3.20.3\npy4j                    0.10.9.7\npyarrow                 14.0.1\npyasn1                  0.4.8\npyasn1-modules          0.2.8\npycparser               2.21\nPyJWT                   2.4.0\npyOpenSSL               23.2.0\nPySocks                 1.7.1\npython-dateutil         2.8.2\npytz                    2023.3.post1\nrequests                2.31.0\nrequests-oauthlib       1.3.0\nrsa                     4.7.2\nscikit-learn            1.3.0\nscipy                   1.11.3\nsetuptools              68.0.0\nsix                     1.16.0\ntensorboard             2.12.1\ntensorboard-data-server 0.7.0\ntensorboard-plugin-wit  1.8.1\ntensorflow              2.12.0\ntensorflow-estimator    2.12.0\ntermcolor               2.1.0\nthreadpoolctl           2.2.0\ntyping_extensions       4.7.1\ntzdata                  2023.3\nurllib3                 1.26.18\nWerkzeug                2.2.3\nwheel                   0.35.1\nwrapt                   1.14.1\nyarl                    1.8.1\n</code></pre>"},{"location":"knime/#knime-environnement-for-keras","title":"Knime environnement for Keras","text":"<p>For Keras a much older environnment is required. </p> <p>For M1 mac, you will need to create an environment using Intel reposititory, to do that you need to prefix conda commands with: <code>CONDA_SUBDIR=osx-64</code></p> <p>Here is the list of packages:</p> <pre><code>Package             Version\n------------------- ---------\nabsl-py             0.15.0\nastor               0.8.1\ncertifi             2021.5.30\ncoverage            5.5\nCython              0.29.24\ndataclasses         0.8\ngast                0.5.3\ngrpcio              1.36.1\nh5py                2.8.0\nimportlib-metadata  4.8.1\nKeras               2.2.4\nKeras-Applications  1.0.8\nKeras-Preprocessing 1.1.2\nMarkdown            3.3.4\nnumpy               1.19.2\npandas              0.23.0\npip                 21.2.2\nprotobuf            3.17.2\npython-dateutil     2.8.2\npytz                2021.3\nPyYAML              5.4.1\nscipy               1.5.2\nsetuptools          58.0.4\nsix                 1.16.0\ntensorboard         1.12.2\ntensorflow          1.12.0\ntermcolor           1.1.0\ntyping_extensions   4.1.1\nWerkzeug            2.0.3\nwheel               0.37.1\nzipp                3.6.0\n</code></pre>"}]}